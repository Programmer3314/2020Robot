

























***Driving Mode***
    {Motor Encoder, Gamepad Arcade Style,}
    Chase ball{Camera turn by vision, forward from human control}
    Drive along trench{Driver controlled speed, ultrasonic sensor, gyro, color sensor, Balls in auto, camera to get angle of trench line on side}
    Target to high target tape{Camera to align with center of tape}
    Align to climb{Gyro to be perpindicular to bar}
    Line up from Control Panel{Weight sensor to detect when hood rips off and back up 2 feet}

***Other Things***
    Pickup ball{Sensor for where the ball is in the intake, Motor ecoder, }
    Shoot{Adjust hood, Adjust motor speed (range) 
    Sensors{Motor Encoder, Prox. Sensor(s) for up and down pos}}
    Climb{Motor Encoder, Index of climber, Sensor for bar Leveling, Sensor for off ground}
    Manage queueing balls (to shooter)
    Spin Control Panel{Sensor for position of spinner motor, Motor Encoder, Color sensor(s), Camera?,  }
    Move along climbing bar
    Control shooter hood
    Driver camera Control{Switching camera, Draw on camera that is chosen }
    

Tasks:

TODO:
PDController was not pushed to the repo

TODO:
Computing target angle: 
 // In pseudocode.

// Compute focal length in pixels from FOV
double f = (0.5 * image_width) / tan(0.5 * fov_radians);

// Vectors subtending image center and pixel from optical center
// in camera coordinates.
// -- in our case (x - center_x) is handled by the Pi
// -- we only want the horizontal angle, so the y-center_y
//    should be ignored (0)
Vector3D center(0, 0, f), pixel(x - center_x, y - center_y, f);

// angle between vector (0, 0, f) and pixel
// -- the dot_product of (a,b,c) and (d,e,f) = a*d+b*e+c*f
//    in this case a & b are always 0, so this dot product = f*f;
// -- the dot product is always positive 
//    so the answer should get the sign (+/-)  
//    of the original x
double dot = dot_product(center, pixel)
double alpha = acos(dot / (center.length() * pixel.length()));   

TODO:
For fixed targets (Power Port): 
Let's try wrapping PDController in another class that 
grabs the gyro angle and the target offset and move to that 
angle based on the gyro. 

